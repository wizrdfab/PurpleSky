<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Live Trading Dashboard</title>
  <style>
    :root {
      --bg1: #0f172a;
      --bg2: #111827;
      --panel: #0b1220;
      --accent: #22c55e;
      --accent2: #f59e0b;
      --danger: #ef4444;
      --muted: #94a3b8;
      --text: #e5e7eb;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Space Grotesk", "Bahnschrift", "Trebuchet MS", sans-serif;
      color: var(--text);
      background: radial-gradient(1200px 600px at 10% 10%, #0b1430 0%, transparent 60%),
                  radial-gradient(1200px 600px at 90% 20%, #1b2a3a 0%, transparent 60%),
                  linear-gradient(160deg, var(--bg1), var(--bg2));
      min-height: 100vh;
    }
    header {
      padding: 28px 32px 10px;
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
      gap: 16px;
    }
    h1 {
      margin: 0;
      font-size: 28px;
      letter-spacing: 0.5px;
    }
    h2 {
      margin: 0;
      font-size: 20px;
      letter-spacing: 0.3px;
    }
    .sub {
      color: var(--muted);
      font-size: 13px;
      margin-top: 6px;
    }
    .pill {
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.08);
      font-size: 12px;
      color: var(--muted);
    }
    .summary-grid {
      padding: 0 32px 16px;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 12px;
    }
    .summary-card {
      background: linear-gradient(180deg, rgba(11,18,32,0.95), rgba(11,18,32,0.85));
      border: 1px solid rgba(148,163,184,0.15);
      border-radius: 14px;
      padding: 12px;
      cursor: pointer;
      transition: transform 0.15s ease, border 0.15s ease;
    }
    .summary-card:hover { transform: translateY(-2px); }
    .summary-card.selected {
      border-color: rgba(34,197,94,0.6);
      box-shadow: 0 0 0 2px rgba(34,197,94,0.2);
    }
    .summary-card.signal-hot {
      border-color: rgba(34,197,94,0.7);
      box-shadow: 0 0 0 2px rgba(34,197,94,0.2), 0 0 18px rgba(34,197,94,0.18);
    }
    .summary-card.signal-hot.short {
      border-color: rgba(239,68,68,0.7);
      box-shadow: 0 0 0 2px rgba(239,68,68,0.2), 0 0 18px rgba(239,68,68,0.18);
    }
    .summary-symbol {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .signal-tag {
      padding: 2px 6px;
      border-radius: 999px;
      font-size: 10px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      border: 1px solid rgba(255,255,255,0.1);
      background: rgba(255,255,255,0.04);
    }
    .signal-tag.long { color: var(--accent); border-color: rgba(34,197,94,0.4); }
    .signal-tag.short { color: var(--danger); border-color: rgba(239,68,68,0.4); }
    .signal-tag.dual { color: #f8fafc; border-color: rgba(148,163,184,0.5); }
    .signal-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--accent);
      box-shadow: 0 0 10px rgba(34,197,94,0.8);
      animation: pulse 1.6s ease-in-out infinite;
    }
    .signal-dot.short {
      background: var(--danger);
      box-shadow: 0 0 10px rgba(239,68,68,0.8);
    }
    .summary-title {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
    }
    .badge {
      padding: 2px 8px;
      border-radius: 999px;
      font-size: 11px;
      border: 1px solid rgba(255,255,255,0.1);
      background: rgba(255,255,255,0.04);
    }
    .badge.ok { color: var(--accent); }
    .badge.warn { color: var(--accent2); }
    .badge.bad { color: var(--danger); }
    .summary-value {
      font-size: 18px;
      font-weight: 600;
    }
    .row {
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      padding: 3px 0;
      border-bottom: 1px dashed rgba(148,163,184,0.1);
    }
    .row:last-child { border-bottom: none; }
    .ok { color: var(--accent); }
    .warn { color: var(--accent2); }
    .bad { color: var(--danger); }
    .muted { color: var(--muted); }
    .strong { font-weight: 700; text-shadow: 0 0 8px rgba(248,250,252,0.25); }
    .pill.signal {
      color: #38bdf8;
      border-color: rgba(56,189,248,0.6);
    }
    .detail-wrap {
      padding: 12px 32px 40px;
    }
    .detail-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
      margin-bottom: 10px;
      gap: 12px;
    }
    .rename-controls {
      margin-top: 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
    }
    .rename-input {
      background: rgba(255,255,255,0.04);
      border: 1px solid rgba(148,163,184,0.25);
      color: var(--text);
      padding: 6px 10px;
      border-radius: 10px;
      font-size: 12px;
      min-width: 200px;
    }
    .rename-input::placeholder { color: var(--muted); }
    .rename-input:disabled,
    .signal-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 16px;
    }
    .feature-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 4px 8px;
      font-size: 11px;
      max-height: 220px;
      overflow-y: auto;
      padding-right: 4px;
    }
    .feature-item {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .truncate {
      max-width: 100%;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      display: block;
    }
    .card {
      background: linear-gradient(180deg, rgba(11,18,32,0.95), rgba(11,18,32,0.85));
      border: 1px solid rgba(148,163,184,0.15);
      border-radius: 16px;
      padding: 16px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.25);
    }
    .card h3 {
      margin: 0 0 10px;
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--muted);
    }
    .value {
      font-size: 24px;
      font-weight: 600;
    }
    canvas {
      width: 100%;
      height: 80px;
      margin-top: 8px;
    }
    .signal-panel {
      margin-top: 18px;
    }
    .signal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
    }
    .signal-chart {
      height: 360px;
      margin-top: 10px;
    }
    .signal-btn {
      border: 1px solid rgba(148,163,184,0.2);
      background: rgba(255,255,255,0.04);
      color: var(--muted);
      padding: 6px 10px;
      border-radius: 10px;
      cursor: pointer;
      font-size: 11px;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      transition: all 0.15s ease;
    }
    .signal-btn.active {
      color: var(--text);
      border-color: rgba(34,197,94,0.6);
      box-shadow: 0 0 0 2px rgba(34,197,94,0.15);
    }
    .signal-list {
      margin-top: 12px;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 10px;
      max-height: 280px;
      overflow-y: auto;
      padding-right: 4px;
    }
    .signal-item {
      border: 1px solid rgba(148,163,184,0.2);
      border-radius: 12px;
      padding: 10px;
      background: rgba(15,23,42,0.55);
      display: grid;
      gap: 6px;
      cursor: pointer;
      transition: transform 0.15s ease, border 0.15s ease;
    }
    .signal-item:hover {
      transform: translateY(-2px);
      border-color: rgba(34,197,94,0.4);
    }
    .signal-item.short:hover {
      border-color: rgba(239,68,68,0.4);
    }
    .signal-item.active {
      border-color: rgba(34,197,94,0.8);
      box-shadow: 0 0 0 2px rgba(34,197,94,0.15);
    }
    .signal-item.short.active {
      border-color: rgba(239,68,68,0.8);
      box-shadow: 0 0 0 2px rgba(239,68,68,0.15);
    }
    .signal-item.hidden {
      display: none;
    }
    .signal-side {
      font-size: 12px;
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }
    .signal-side.long { color: var(--accent); }
    .signal-side.short { color: var(--danger); }
    .signal-meta {
      font-size: 11px;
      color: var(--muted);
    }
    .signal-values {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 6px;
      font-size: 12px;
    }
    .signal-values span {
      display: block;
      font-size: 11px;
      color: var(--muted);
    }
    @keyframes pulse {
      0% { transform: scale(0.9); opacity: 0.6; }
      50% { transform: scale(1.2); opacity: 1; }
      100% { transform: scale(0.9); opacity: 0.6; }
    }
    .chart-large {
      height: 300px;
    }
    #icebergChart {
      height: 420px;
    }
    .nav-tabs {
      padding: 0 32px 8px;
      display: flex;
      gap: 8px;
    }
    .nav-btn {
      border: 1px solid rgba(148,163,184,0.2);
      background: rgba(255,255,255,0.04);
      color: var(--muted);
      padding: 8px 14px;
      border-radius: 10px;
      cursor: pointer;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      transition: all 0.15s ease;
    }
    .nav-btn.active {
      color: var(--text);
      border-color: rgba(34,197,94,0.6);
      box-shadow: 0 0 0 2px rgba(34,197,94,0.15);
    }
    .section {
      display: none;
    }
    .section.active {
      display: block;
    }
    .account-header {
      padding: 12px 32px 0;
      display: flex;
      align-items: flex-end;
      justify-content: space-between;
      gap: 16px;
    }
    .account-grid {
      padding: 12px 32px 0;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 16px;
    }
    .account-chart {
      margin: 16px 32px;
      position: relative;
    }
    .chart-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
      gap: 12px;
    }
    .chart-controls {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 6px;
    }
    .toggle-group {
      display: flex;
      gap: 6px;
    }
    .toggle-btn {
      border: 1px solid rgba(148,163,184,0.2);
      background: rgba(255,255,255,0.04);
      color: var(--muted);
      padding: 4px 10px;
      border-radius: 999px;
      cursor: pointer;
      font-size: 11px;
      transition: all 0.15s ease;
    }
    .toggle-btn.active {
      color: var(--text);
      border-color: rgba(34,197,94,0.6);
      box-shadow: 0 0 0 2px rgba(34,197,94,0.15);
    }
    .range-group {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }
    .range-btn {
      border: 1px solid rgba(148,163,184,0.2);
      background: rgba(255,255,255,0.04);
      color: var(--muted);
      padding: 4px 10px;
      border-radius: 999px;
      cursor: pointer;
      font-size: 11px;
    }
    .range-btn.active {
      color: var(--text);
      border-color: rgba(56,189,248,0.6);
      box-shadow: 0 0 0 2px rgba(56,189,248,0.15);
    }
    .legend {
      display: flex;
      gap: 12px;
      font-size: 12px;
      color: var(--muted);
      margin-top: 6px;
    }
    .legend span::before {
      content: "";
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 999px;
      margin-right: 6px;
      vertical-align: middle;
    }
    .legend .raw::before { background: #38bdf8; }
    .legend .adjusted::before { background: #22c55e; }
    .legend .inactive {
      color: rgba(148,163,184,0.6);
    }
    .profile-list {
      display: grid;
      gap: 6px;
      font-size: 12px;
    }
    .profile-row {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 8px;
      border-bottom: 1px dashed rgba(148,163,184,0.12);
      padding-bottom: 4px;
    }
    .profile-row:last-child {
      border-bottom: none;
      padding-bottom: 0;
    }
    .profile-meta {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    .profile-metrics {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 4px;
    }
    .profile-spark {
      width: 120px;
      height: 26px;
    }
    .tooltip {
      position: absolute;
      display: none;
      pointer-events: none;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid rgba(148, 163, 184, 0.25);
      color: var(--text);
      padding: 8px 10px;
      border-radius: 10px;
      font-size: 12px;
      box-shadow: 0 10px 20px rgba(0,0,0,0.35);
      white-space: nowrap;
    }
  </style>
</head>
<body>
  <header>
    <div>
      <h1>Live Trading Dashboard</h1>
      <div class="sub" id="subline">Waiting for metrics...</div>
    </div>
    <div class="pill" id="statusPill">Offline</div>
  </header>

  <nav class="nav-tabs">
    <button class="nav-btn active" id="tabAccount" data-view="account">Account Balance</button>
    <button class="nav-btn" id="tabTraders" data-view="traders">Traders</button>
    <button class="nav-btn" id="tabChart" data-view="chart">Chart</button>
  </nav>

  <section id="accountSection" class="section active">
    <div class="account-header">
      <div>
        <h2>Account Balance</h2>
        <div class="sub" id="accountSub">Waiting for balance updates...</div>
      </div>
      <div class="pill" id="accountStatus">--</div>
    </div>
    <div class="account-grid">
      <div class="card">
        <h3>Total Balance</h3>
        <div class="value" id="aggBalance">--</div>
        <div class="row"><span>Available</span><span id="aggAvailable">--</span></div>
        <div class="row"><span>Profiles</span><span id="aggProfiles">--</span></div>
      </div>
      <div class="card">
        <h3>Unified Account</h3>
        <div class="value" id="aggUnified">--</div>
        <div class="row"><span>Share</span><span id="aggUnifiedShare">--</span></div>
        <div class="row"><span>Updated</span><span id="aggUpdated">--</span></div>
      </div>
      <div class="card">
        <h3>Funding Account</h3>
        <div class="value" id="aggFunding">--</div>
        <div class="row"><span>Share</span><span id="aggFundingShare">--</span></div>
        <div class="row"><span>Flow Events</span><span id="aggFlows">--</span></div>
      </div>
      <div class="card">
        <h3>Performance</h3>
        <div class="value" id="aggReturn">--</div>
        <div class="row"><span>Max DD</span><span id="aggMaxDD">--</span></div>
        <div class="row"><span>Volatility</span><span id="aggVolatility">--</span></div>
        <div class="row"><span>Stability</span><span id="aggStability">--</span></div>
      </div>
    </div>
    <div class="card account-chart">
      <div class="chart-header">
        <div>
          <h3>Balance Curve (Raw + Flow-Adjusted)</h3>
          <div class="sub" id="balanceNote">Flow-adjusted removes large deposits/withdrawals.</div>
        </div>
        <div class="chart-controls">
          <div class="range-group" id="balanceRange">
            <button class="range-btn active" data-range="all">All</button>
            <button class="range-btn" data-range="7d">7D</button>
            <button class="range-btn" data-range="1d">1D</button>
            <button class="range-btn" data-range="24h">24H</button>
            <button class="range-btn" data-range="6h">6H</button>
            <button class="range-btn" data-range="1h">1H</button>
          </div>
          <div class="range-group" id="balanceScale">
            <button class="range-btn active" data-scale="split">Split Scale</button>
            <button class="range-btn" data-scale="shared">Shared Scale</button>
          </div>
          <div class="toggle-group" id="balanceToggle">
            <button class="toggle-btn active" data-toggle="raw">Raw Curve</button>
            <button class="toggle-btn active" data-toggle="adjusted">Flow-Adjusted</button>
          </div>
        </div>
      </div>
      <canvas id="balanceChart" class="chart-large"></canvas>
      <div id="balanceTooltip" class="tooltip"></div>
      <div class="legend">
        <span class="raw">Raw</span>
        <span class="adjusted">Flow-adjusted</span>
      </div>
    </div>
    <div class="account-grid">
      <div class="card">
        <h3>Curve Diagnostics</h3>
        <div class="row"><span>Smoothness</span><span id="aggSmoothness">--</span></div>
        <div class="row"><span>Trend / Day</span><span id="aggTrend">--</span></div>
        <div class="row"><span>Raw Return</span><span id="aggRawReturn">--</span></div>
        <div class="row"><span>Points</span><span id="aggPoints">--</span></div>
      </div>
      <div class="card">
        <h3>Profiles</h3>
        <div class="profile-list" id="accountProfiles">--</div>
      </div>
    </div>
  </section>

  <section id="tradersSection" class="section">
    <section class="summary-grid" id="summaryGrid"></section>
    <section class="detail-wrap">
      <div class="detail-header">
        <div>
          <h2 id="detailTitle">Select a model</h2>
          <div class="sub" id="detailSub">No data loaded</div>
          <div class="rename-controls">
            <input class="rename-input" id="aliasInput" type="text" placeholder="Display name" autocomplete="off"/>
            <button class="signal-btn" id="aliasSave">Save</button>
            <button class="signal-btn" id="aliasClear">Reset</button>
          </div>
        </div>
        <div class="pill" id="detailStatus">--</div>
      </div>
      <div class="grid">
        <div class="card">
          <h3>Equity and PnL</h3>
          <div class="value" id="equityVal">--</div>
          <div class="row"><span>Daily PnL</span><span id="dailyPnl">--</span></div>
          <div class="row"><span>Unrealized</span><span id="unrealPnl">--</span></div>
          <canvas id="equityChart"></canvas>
        </div>
        <div class="card">
          <h3>Position</h3>
          <div class="value" id="posSide">--</div>
          <div class="row"><span>Size</span><span id="posSize">--</span></div>
          <div class="row"><span>Entry</span><span id="posEntry">--</span></div>
          <div class="row"><span>Mark</span><span id="posMark">--</span></div>
          <div class="row"><span>TP / SL</span><span id="posTPSL">--</span></div>
        </div>
        <div class="card">
          <h3>Health</h3>
          <div class="value" id="healthVal">--</div>
          <div class="row"><span>Sentiment</span><span id="sentimentVal">--</span></div>
          <div class="row"><span>Regime</span><span id="regimeVal">--</span></div>
          <div class="row"><span>Trade Enabled</span><span id="tradeEnabled">--</span></div>
          <div class="row"><span>Drift Alerts</span><span id="driftAlerts">--</span></div>
        </div>
        <div class="card">
          <h3>Model</h3>
          <div class="value" id="modelPred">--</div>
          <div class="row"><span>Pred Long</span><span id="predLong">--</span></div>
          <div class="row"><span>Pred Short</span><span id="predShort">--</span></div>
          <div class="row"><span>Dir Long</span><span id="dirLong">--</span></div>
          <div class="row"><span>Dir Short</span><span id="dirShort">--</span></div>
          <div class="row"><span>Threshold</span><span id="predThreshold">--</span></div>
          <div class="row"><span>Pred Bar</span><span id="predBar">--</span></div>
          <div class="row"><span>Dir Threshold</span><span id="dirThreshold">--</span></div>
          <div class="row"><span>Aggressive</span><span id="dirAggressive">--</span></div>
          <div class="row"><span>Dir Bar</span><span id="dirBar">--</span></div>
          <div class="row"><span>Model Path</span><span class="truncate" id="modelPath">--</span></div>
          <div class="row"><span>Keys Profile</span><span id="keysProfile">--</span></div>
        </div>
        <div class="card">
          <h3>Signal</h3>
          <div class="value" id="signalStatus">--</div>
          <div class="row"><span>Side</span><span id="signalSide">--</span></div>
          <div class="row"><span>Entry Price</span><span id="signalEntry">--</span></div>
          <div class="row"><span>TP Price</span><span id="signalTP">--</span></div>
          <div class="row"><span>SL Price</span><span id="signalSL">--</span></div>
          <div class="row"><span>Time</span><span id="signalTime">--</span></div>
        </div>
        <div class="card">
          <h3>Data Quality</h3>
          <div class="value" id="barsVal">--</div>
          <div class="row"><span>Macro %</span><span id="macroPct">--</span></div>
          <div class="row"><span>OB Density</span><span id="obDensity">--</span></div>
          <div class="row"><span>Trade Continuity</span><span id="tradeCont">--</span></div>
          <div class="row"><span>Lag Trade / Bar</span><span id="lagTradeBar">--</span></div>
        </div>
        <div class="card">
          <h3>Latency</h3>
          <div class="value" id="restLatency">--</div>
          <div class="row"><span>WS Trade</span><span id="wsTrade">--</span></div>
          <div class="row"><span>WS OB</span><span id="wsOb">--</span></div>
          <div class="row"><span>OB Lag</span><span id="obLag">--</span></div>
          <canvas id="latencyChart"></canvas>
        </div>
        <div class="card">
          <h3>Orders</h3>
          <div class="value" id="openOrders">--</div>
          <div class="row"><span>Last Reconcile</span><span id="lastReconcile">--</span></div>
          <div class="row"><span>Source</span><span id="reconcileSource">--</span></div>
          <div class="row"><span>Protective</span><span id="protectiveCount">--</span></div>
        </div>
        <div class="card">
          <h3>Errors</h3>
          <div class="value" id="errorCount">--</div>
          <div class="row"><span>Last Runtime</span><span id="lastRuntime">--</span></div>
          <div class="row"><span>Last API</span><span id="lastApi">--</span></div>
        </div>
        <div class="card">
          <h3>Features</h3>
          <div class="feature-grid" id="featureList">--</div>
        </div>
      </div>
      <div class="card signal-panel">
        <div class="signal-header">
          <div>
            <h3>Signal Stream</h3>
            <div class="sub" id="signalSub">Waiting for signals...</div>
          </div>
          <button class="signal-btn" id="signalClear">Show All</button>
        </div>
        <div id="signalChart" class="signal-chart"></div>
        <div class="signal-list" id="signalList">--</div>
      </div>
    </section>
  </section>

  <section id="chartSection" class="section">
    <div class="detail-header">
      <div>
        <h2 id="chartTitle">Chart</h2>
        <div class="sub" id="chartSub">Select a model to view price.</div>
      </div>
      <div class="pill" id="chartStatus">--</div>
    </div>
    <div class="account-chart">
      <div class="chart-header">
        <div>
          <h3>Price and Iceberg Levels</h3>
          <div class="sub" id="icebergChartMeta">--</div>
        </div>
        <div class="chart-controls">
          <div class="range-group" id="chartRange">
            <button class="range-btn active" data-range="15m">15M</button>
            <button class="range-btn" data-range="30m">30M</button>
            <button class="range-btn" data-range="1h">1H</button>
            <button class="range-btn" data-range="4h">4H</button>
            <button class="range-btn" data-range="6h">6H</button>
            <button class="range-btn" data-range="24h">24H</button>
            <button class="range-btn" data-range="1d">1D</button>
          </div>
        </div>
      </div>
      <div id="icebergChart" class="chart-large"></div>
    </div>
  </section>

  <script>
    const fmt = (v, d=2) => (v === null || v === undefined) ? "--" : Number(v).toFixed(d);
    const fmtPct = (v) => (v === null || v === undefined) ? "--" : `${Number(v).toFixed(1)}%`;
    const fmtSec = (v) => (v === null || v === undefined) ? "--" : `${Number(v).toFixed(1)}s`;
    const fmtMs = (v) => (v === null || v === undefined) ? "--" : `${Number(v).toFixed(1)}ms`;
    const numOrNaN = (value) => {
      if (value === null || value === undefined || value === "") return NaN;
      const num = Number(value);
      return Number.isFinite(num) ? num : NaN;
    };
    const ALIAS_STORAGE_KEY = "dash_aliases_v1";
    const loadAliases = () => {
      try {
        const raw = localStorage.getItem(ALIAS_STORAGE_KEY);
        if (!raw) return {};
        const data = JSON.parse(raw);
        return data && typeof data === "object" ? data : {};
      } catch (err) {
        return {};
      }
    };
    const saveAliases = (aliases) => {
      try {
        localStorage.setItem(ALIAS_STORAGE_KEY, JSON.stringify(aliases || {}));
      } catch (err) {
        return;
      }
    };

    const state = {
      selected: null,
      selectedSymbol: null,
      selectedLabel: null,
      latestMap: {},
      items: [],
      lastHistoryKey: null,
      view: "account",
      balanceRange: "all",
      balanceScale: "split",
      balanceShowRaw: true,
      balanceShowAdjusted: true,
      balanceHistory: [],
      balanceFlowPct: 2.0,
      balancePlot: null,
      balanceLatest: null,
      signalHistory: [],
      signalCandles: [],
      signalFocusId: null,
      signalChart: null,
      signalChartLoading: false,
      signalKey: null,
      signalSymbol: null,
      signalLastCandleFetch: 0,
      signalZoom: null,
      signalZoomActive: false,
      signalZoomBound: false,
      signalCache: {},
      directionHistory: [],
      directionKey: null,
      aliases: loadAliases()
    };

    function sparkline(canvas, values, color) {
      const ctx = canvas.getContext("2d");
      const w = canvas.width = canvas.clientWidth;
      const h = canvas.height = canvas.clientHeight;
      ctx.clearRect(0, 0, w, h);
      if (!values.length) return;
      const min = Math.min(...values);
      const max = Math.max(...values);
      const span = (max - min) || 1;
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.beginPath();
      values.forEach((v, i) => {
        const x = (i / (values.length - 1)) * w;
        const y = h - ((v - min) / span) * h;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      ctx.stroke();
    }

    function parseTs(ts) {
      if (!ts) return null;
      const iso = ts.replace(" ", "T") + "Z";
      const ms = Date.parse(iso);
      return Number.isNaN(ms) ? null : ms;
    }

    function latestTimestamp(history) {
      for (let i = history.length - 1; i >= 0; i--) {
        const ts = parseTs(history[i]?.ts);
        if (ts) return ts;
      }
      return null;
    }

    function signalTimestampMs(signal) {
      if (!signal) return null;
      const tsMs = Number(signal.ts_ms || 0);
      if (tsMs > 0) return tsMs;
      if (signal.ts) {
        const parsed = parseTs(String(signal.ts));
        if (parsed) return parsed;
      }
      const barTime = Number(signal.bar_time || 0);
      return barTime > 0 ? barTime * 1000 : null;
    }

    function formatSignalTime(signal) {
      const ms = signalTimestampMs(signal);
      if (!ms) return "--";
      return new Date(ms).toLocaleString();
    }

    function signalSideKey(side) {
      const val = (side || "").toString().toLowerCase();
      if (val === "buy" || val === "long") return "long";
      if (val === "sell" || val === "short") return "short";
      return "";
    }

    function signalSideLabel(side) {
      const key = signalSideKey(side);
      if (key === "long") return "LONG";
      if (key === "short") return "SHORT";
      return "--";
    }

    function computeSignalTargets(signal, entry) {
      const atr = Number((signal && signal.atr) || 0);
      const tpAtr = Number((signal && signal.tp_atr) || 0);
      const slAtr = Number((signal && signal.sl_atr) || 0);
      if (entry <= 0 || atr <= 0 || tpAtr <= 0 || slAtr <= 0) {
        return { tp: 0, sl: 0 };
      }
      const side = signalSideKey(signal && signal.side);
      let tp = entry + (atr * tpAtr);
      let sl = entry - (atr * slAtr);
      if (side === "short") {
        tp = entry - (atr * tpAtr);
        sl = entry + (atr * slAtr);
      }
      const tick = Number((signal && signal.tick_size) || 0);
      if (tick > 0) {
        if (side === "short") {
          tp = Math.floor(tp / tick) * tick;
          sl = Math.ceil(sl / tick) * tick;
        } else {
          tp = Math.ceil(tp / tick) * tick;
          sl = Math.floor(sl / tick) * tick;
        }
      }
      return { tp, sl };
    }

    function computeSignalState(prediction, direction) {
      const predLong = Number(prediction?.pred_long || 0);
      const predShort = Number(prediction?.pred_short || 0);
      const threshold = Number(prediction?.threshold || 0);
      const dirLong = Number(direction?.pred_long || 0);
      const dirShort = Number(direction?.pred_short || 0);
      const dirThreshold = numOrNaN(direction?.threshold);
      const aggressiveThreshold = numOrNaN(direction?.aggressive_threshold);
      const gateEnabled = Number.isFinite(dirThreshold) && Number.isFinite(aggressiveThreshold);
      const longGateOk = !gateEnabled || dirLong > dirThreshold;
      const shortGateOk = !gateEnabled || dirShort > dirThreshold;
      const activeLong = predLong > threshold && longGateOk;
      const activeShort = predShort > threshold && shortGateOk;
      let side = "";
      if (activeLong && activeShort) {
        side = "dual";
      } else if (activeLong) {
        side = "long";
      } else if (activeShort) {
        side = "short";
      }
      return {
        active: activeLong || activeShort,
        side,
        predLong,
        predShort,
        threshold
      };
    }

    function pickDominantSignal(signals) {
      if (!Array.isArray(signals) || !signals.length) return null;
      let best = signals[0];
      let bestScore = Number(best.pred || 0);
      for (let i = 1; i < signals.length; i++) {
        const score = Number(signals[i].pred || 0);
        if (score > bestScore) {
          best = signals[i];
          bestScore = score;
        }
      }
      return best;
    }

    function clamp01(val) {
      if (!Number.isFinite(val)) return 0;
      return Math.max(0, Math.min(1, val));
    }

    function signalStrength(pred) {
      return clamp01(Number(pred || 0));
    }

    function signalMarkerStyle(side, pred) {
      const strength = signalStrength(pred);
      const base = side === "short" ? [239, 68, 68] : [34, 197, 94];
      const alpha = 0.35 + strength * 0.65;
      const glow = 0.2 + strength * 0.5;
      const color = `rgba(${base[0]},${base[1]},${base[2]},${alpha})`;
      const shadowColor = `rgba(${base[0]},${base[1]},${base[2]},${glow})`;
      let borderColor = "rgba(0,0,0,0)";
      let borderWidth = 0;
      if (strength >= 0.9) {
        borderColor = "#f59e0b";
        borderWidth = 2;
      } else if (strength >= 0.8) {
        borderColor = "rgba(248,250,252,0.6)";
        borderWidth = 1;
      }
      const size = 8 + strength * 12;
      const shadowBlur = 6 + strength * 10;
      return { color, borderColor, borderWidth, size, shadowColor, shadowBlur };
    }

    function tickDecimals(tick) {
      const num = Number(tick);
      if (!Number.isFinite(num) || num <= 0) return 6;
      const text = num.toString();
      if (text.includes("e-")) {
        const exp = Number(text.split("e-")[1]);
        return Number.isFinite(exp) ? exp : 6;
      }
      const dot = text.indexOf(".");
      return dot === -1 ? 0 : (text.length - dot - 1);
    }

    function formatSignalPrice(value, tick) {
      if (value === null || value === undefined) return "--";
      const num = Number(value);
      if (!Number.isFinite(num) || num === 0) return "--";
      const decimals = tickDecimals(tick);
      return fmt(num, decimals);
    }

    function drawBalanceChart(canvas, rawSeries, adjustedSeries, scaleMode, showRaw, showAdjusted) {
      const ctx = canvas.getContext("2d");
      const w = canvas.width = canvas.clientWidth;
      const h = canvas.height = canvas.clientHeight;
      ctx.clearRect(0, 0, w, h);
      const activeRaw = showRaw ? rawSeries : [];
      const activeAdj = showAdjusted ? adjustedSeries : [];
      const combined = [...activeRaw, ...activeAdj];
      if (!combined.length) return;
      const pad = 10;
      const scaleX = (i, n) => (n <= 1 ? pad : (i / (n - 1)) * (w - pad * 2) + pad);

      const rawMin = activeRaw.length ? Math.min(...activeRaw) : combined[0];
      const rawMax = activeRaw.length ? Math.max(...activeRaw) : combined[0];
      const adjMin = activeAdj.length ? Math.min(...activeAdj) : combined[0];
      const adjMax = activeAdj.length ? Math.max(...activeAdj) : combined[0];
      const combinedMin = Math.min(rawMin, adjMin);
      const combinedMax = Math.max(rawMax, adjMax);

      const useShared = (scaleMode || "shared") === "shared";
      const minRaw = useShared ? combinedMin : rawMin;
      const maxRaw = useShared ? combinedMax : rawMax;
      const minAdj = useShared ? combinedMin : adjMin;
      const maxAdj = useShared ? combinedMax : adjMax;

      const spanRaw = (maxRaw - minRaw) || 1;
      const spanAdj = (maxAdj - minAdj) || 1;
      const scaleYRaw = (v) => h - pad - ((v - minRaw) / spanRaw) * (h - pad * 2);
      const scaleYAdj = (v) => h - pad - ((v - minAdj) / spanAdj) * (h - pad * 2);

      const drawGrid = () => {
        const lines = 4;
        ctx.strokeStyle = "rgba(148,163,184,0.12)";
        ctx.lineWidth = 1;
        for (let i = 0; i <= lines; i++) {
          const val = maxRaw - ((maxRaw - minRaw) * (i / lines));
          const y = scaleYRaw(val);
          ctx.beginPath();
          ctx.moveTo(pad, y);
          ctx.lineTo(w - pad, y);
          ctx.stroke();
        }
      };

      const drawLine = (series, color, scaleY) => {
        if (!series || !series.length) return;
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        series.forEach((v, i) => {
          const x = scaleX(i, series.length);
          const y = scaleY(v);
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        });
        ctx.stroke();
      };

      drawGrid();
      if (showRaw) {
        drawLine(rawSeries, "#38bdf8", scaleYRaw);
      }
      if (showAdjusted) {
        drawLine(adjustedSeries, "#22c55e", scaleYAdj);
      }

      ctx.fillStyle = "rgba(148,163,184,0.8)";
      ctx.font = "11px Space Grotesk, sans-serif";
      const rawLabel = `Raw ${fmt(maxRaw, 2)} / ${fmt(minRaw, 2)}`;
      ctx.fillText(rawLabel, pad, pad + 2);
      if (!useShared) {
        const adjLabel = `Adj ${fmt(maxAdj, 2)} / ${fmt(minAdj, 2)}`;
        const textWidth = ctx.measureText(adjLabel).width;
        ctx.fillText(adjLabel, w - textWidth - pad, pad + 2);
      }
    }

    function setupBalanceTooltip() {
      const canvas = document.getElementById("balanceChart");
      const tooltip = document.getElementById("balanceTooltip");
      if (!canvas || !tooltip) return;

      canvas.addEventListener("mousemove", (evt) => {
        if (!state.balancePlot) return;
        const rect = canvas.getBoundingClientRect();
        const cardRect = canvas.parentElement.getBoundingClientRect();
        const x = evt.clientX - rect.left;
        const n = state.balancePlot.raw.length;
        const idx = Math.min(n - 1, Math.max(0, Math.round((x / rect.width) * (n - 1))));
        const raw = state.balanceShowRaw ? state.balancePlot.raw[idx] : null;
        const adj = state.balanceShowAdjusted ? state.balancePlot.adjusted[idx] : null;
        const ts = state.balancePlot.labels[idx];
        let timeText = "--";
        if (ts) {
          const parsed = parseTs(ts);
          if (parsed) {
            timeText = new Date(parsed).toLocaleString();
          }
        }
        tooltip.style.display = "block";
        const parts = [];
        if (raw !== null && raw !== undefined) {
          parts.push(`Raw: ${fmt(raw, 4)}`);
        }
        if (adj !== null && adj !== undefined) {
          parts.push(`Adj: ${fmt(adj, 4)}`);
        }
        tooltip.textContent = `${timeText} | ${parts.length ? parts.join(" | ") : "No series visible"}`;
        const left = Math.min(cardRect.width - tooltip.offsetWidth - 8, Math.max(8, (rect.left - cardRect.left) + x + 12));
        tooltip.style.left = `${left}px`;
        tooltip.style.top = `${Math.max(8, (rect.top - cardRect.top) + (evt.clientY - rect.top) - 24)}px`;
      });

      canvas.addEventListener("mouseleave", () => {
        tooltip.style.display = "none";
      });
    }

    function computeAdjustedSeries(series, flowPct) {
      if (!series.length) return { adjusted: [], flowEvents: 0 };
      const adjusted = [series[0]];
      let flow = 0;
      let flowEvents = 0;
      for (let i = 1; i < series.length; i++) {
        const prev = series[i - 1];
        const delta = series[i] - prev;
        const threshold = Math.max(1, prev * (flowPct / 100));
        if (Math.abs(delta) > threshold) {
          flow += delta;
          flowEvents += 1;
        }
        adjusted.push(series[i] - flow);
      }
      return { adjusted, flowEvents };
    }

    function filterHistory(history, range) {
      if (!history.length || range === "all") return history;
      const lastTs = latestTimestamp(history);
      if (!lastTs) return history;
      if (range === "1d") {
        const d = new Date(lastTs);
        const cutoff = Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate());
        return history.filter(item => {
          const ts = parseTs(item.ts);
          return ts && ts >= cutoff;
        });
      }
      const windowMap = {
        "7d": 7 * 24 * 60 * 60 * 1000,
        "24h": 24 * 60 * 60 * 1000,
        "6h": 6 * 60 * 60 * 1000,
        "1h": 60 * 60 * 1000
      };
      const windowMs = windowMap[range] || 0;
      if (!windowMs) return history;
      const cutoff = lastTs - windowMs;
      return history.filter(item => {
        const ts = parseTs(item.ts);
        return ts && ts >= cutoff;
      });
    }

    function healthClass(text) {
      if (!text) return "muted";
      const upper = text.toUpperCase();
      if (upper.includes("CRITICAL") || upper.includes("ERROR")) return "bad";
      if (upper.includes("WARNING") || upper.includes("WARN")) return "warn";
      if (upper.includes("HEALTHY") || upper.includes("STABLE")) return "ok";
      return "muted";
    }

    function setDirectionValue(id, value, threshold, aggressive, side) {
      const el = document.getElementById(id);
      if (!el) return;
      const num = Number(value);
      if (!Number.isFinite(num)) {
        el.textContent = "--";
        el.className = "";
        return;
      }
      el.textContent = fmt(num, 3);
      let cls = "";
      if (Number.isFinite(aggressive) && num >= aggressive) {
        cls = side === "short" ? "bad strong" : "ok strong";
      } else if (Number.isFinite(threshold) && num >= threshold) {
        cls = side === "short" ? "bad" : "ok";
      }
      el.className = cls;
    }

    function entryKey(item) {
      if (!item) return null;
      return item.dash_key || item.symbol || null;
    }

    function normalizeAlias(value) {
      if (value === null || value === undefined) return "";
      return String(value).trim();
    }

    function aliasForKey(key) {
      if (!key) return "";
      const alias = state.aliases ? state.aliases[key] : "";
      return normalizeAlias(alias);
    }

    function displayNameFor(key, symbol) {
      const alias = aliasForKey(key);
      if (alias) return alias;
      if (symbol) return symbol;
      return key || "--";
    }

    function setAliasForKey(key, value) {
      if (!key) return;
      const alias = normalizeAlias(value);
      if (!state.aliases) state.aliases = {};
      if (alias) {
        state.aliases[key] = alias;
      } else {
        delete state.aliases[key];
      }
      saveAliases(state.aliases);
    }

    function syncAliasControls(key, symbol) {
      const input = document.getElementById("aliasInput");
      const saveBtn = document.getElementById("aliasSave");
      const clearBtn = document.getElementById("aliasClear");
      if (!input || !saveBtn || !clearBtn) return;
      const alias = aliasForKey(key);
      const enabled = Boolean(key);
      input.disabled = !enabled;
      saveBtn.disabled = !enabled;
      clearBtn.disabled = !enabled || !alias;
      const currentKey = input.dataset.aliasKey || "";
      const nextKey = key || "";
      const isFocused = document.activeElement === input;
      if (isFocused && currentKey === nextKey) {
        return;
      }
      input.dataset.aliasKey = nextKey;
      input.placeholder = symbol ? `Display name (${symbol})` : "Display name";
      input.value = alias;
    }

    function stripQuoteSymbol(symbol) {
      if (!symbol) return "";
      const upper = symbol.toUpperCase();
      if (upper.endsWith("USDT")) return symbol.slice(0, -4);
      if (upper.endsWith("USDC")) return symbol.slice(0, -4);
      return symbol;
    }

    function modelFolderSuffix(modelDir) {
      if (!modelDir) return "";
      const cleaned = String(modelDir).replace(/\\/g, "/");
      const parts = cleaned.split("/").filter(Boolean);
      if (!parts.length) return "";
      let folder = parts[parts.length - 1];
      if (folder.toLowerCase().startsWith("rank_") && parts.length >= 2) {
        folder = parts[parts.length - 2];
      }
      const idx = folder.indexOf("_");
      if (idx < 0 || idx >= folder.length - 1) return "";
      return folder.slice(idx + 1);
    }

    function modelLabel(item) {
      if (!item) return "--";
      const symbol = String(item.symbol || item.dash_key || "");
      const base = stripQuoteSymbol(symbol);
      const model = item.model || {};
      const suffix = modelFolderSuffix(model.dir);
      if (base && suffix) return `${base} ${suffix}`;
      if (base) return base;
      if (suffix) return suffix;
      if (model.keys_profile) return String(model.keys_profile);
      return "--";
    }

    function renderSummary(items) {
      state.items = items || [];
      state.latestMap = {};
      const grid = document.getElementById("summaryGrid");
      grid.innerHTML = "";
      state.items.forEach(item => {
        const key = entryKey(item);
        if (!key) return;
        state.latestMap[key] = item;
      });
      const entries = Object.values(state.latestMap).sort((a, b) => {
        const symA = (a.symbol || "").toString();
        const symB = (b.symbol || "").toString();
        if (symA !== symB) return symA.localeCompare(symB);
        const keyA = entryKey(a) || "";
        const keyB = entryKey(b) || "";
        return String(keyA).localeCompare(String(keyB));
      });
      document.getElementById("statusPill").textContent = `${entries.length} models`;
      const subline = document.getElementById("subline");
      if (subline) {
        subline.textContent = `Active models: ${entries.length} | Updated: ${new Date().toLocaleTimeString()}`;
      }
      if (!state.selected || !state.latestMap[state.selected]) {
        state.selected = entries.length ? entryKey(entries[0]) : null;
      }
      entries.forEach(item => {
        const key = entryKey(item);
        const symbol = item.symbol || key || "--";
        const displayName = displayNameFor(key, symbol);
        const card = document.createElement("div");
        const signalState = computeSignalState(item.prediction || {}, item.direction || {});
        const signalClasses = [];
        if (signalState.active) {
          signalClasses.push("signal-hot");
          if (signalState.side === "short") {
            signalClasses.push("short");
          }
        }
        card.className = ["summary-card", key === state.selected ? "selected" : "", ...signalClasses]
          .filter(Boolean)
          .join(" ");
        card.addEventListener("click", () => selectSymbol(key));

        const title = document.createElement("div");
        title.className = "summary-title";
        const labelWrap = document.createElement("div");
        labelWrap.className = "summary-symbol";
        const label = document.createElement("span");
        label.textContent = displayName;
        if (displayName !== symbol) {
          label.title = symbol;
        }
        labelWrap.appendChild(label);
        if (signalState.active) {
          const dot = document.createElement("span");
          dot.className = "signal-dot" + (signalState.side === "short" ? " short" : "");
          labelWrap.appendChild(dot);
          const tag = document.createElement("span");
          tag.className = "signal-tag " + (signalState.side || "");
          tag.textContent = signalState.side === "dual" ? "DUAL" : signalState.side.toUpperCase();
          labelWrap.appendChild(tag);
        }
        const badge = document.createElement("span");
        if (item.signal_only) {
          badge.className = "badge ok";
          badge.textContent = "SIGNAL";
        } else {
          badge.className = "badge " + (item.trade_enabled ? "ok" : "warn");
          badge.textContent = item.trade_enabled ? "ON" : "OFF";
        }
        title.appendChild(labelWrap);
        title.appendChild(badge);
        card.appendChild(title);

        const equity = document.createElement("div");
        equity.className = "summary-value";
        equity.textContent = item.equity ? fmt(item.equity, 4) : "--";
        card.appendChild(equity);

        let signalText = "None";
        if (signalState.active) {
          if (signalState.side === "long") {
            signalText = `LONG ${fmt(signalState.predLong, 3)}`;
          } else if (signalState.side === "short") {
            signalText = `SHORT ${fmt(signalState.predShort, 3)}`;
          } else {
            const peak = Math.max(signalState.predLong, signalState.predShort);
            signalText = `DUAL ${fmt(peak, 3)}`;
          }
        }
        const rows = [
          ["Model", modelLabel(item)],
          ["Daily PnL", fmt(item.daily_pnl, 4)],
          ["Position", formatPosition(item.position)],
          ["Health", item.health?.status || "--"],
          ["Signal", signalText],
          ["OB Density", fmtPct(item.data_health?.ob_density_pct)],
          ["Lag Trade", fmtSec(item.latency?.lag_trade_sec)],
          ["Last Update", item.ts || "--"],
        ];
        rows.forEach(([k, v]) => {
          const row = document.createElement("div");
          row.className = "row";
          const left = document.createElement("span");
          left.textContent = k;
          const right = document.createElement("span");
          right.textContent = v;
          if (k === "Model") {
            right.className = "truncate";
            right.title = v;
          }
          row.appendChild(left);
          row.appendChild(right);
          card.appendChild(row);
        });
        grid.appendChild(card);
      });
      if (state.selected && state.latestMap[state.selected]) {
        updateDetail(state.latestMap[state.selected]);
      }
    }

    function setView(view) {
      state.view = view;
      const accountSection = document.getElementById("accountSection");
      const tradersSection = document.getElementById("tradersSection");
      const chartSection = document.getElementById("chartSection");
      const tabAccount = document.getElementById("tabAccount");
      const tabTraders = document.getElementById("tabTraders");
      const tabChart = document.getElementById("tabChart");
      if (view === "account") {
        accountSection.classList.add("active");
        tradersSection.classList.remove("active");
        chartSection.classList.remove("active");
        tabAccount.classList.add("active");
        tabTraders.classList.remove("active");
        tabChart.classList.remove("active");
      } else if (view === "chart") {
        chartSection.classList.add("active");
        accountSection.classList.remove("active");
        tradersSection.classList.remove("active");
        tabChart.classList.add("active");
        tabAccount.classList.remove("active");
        tabTraders.classList.remove("active");
        if (typeof window.refreshIcebergChart === "function") {
          window.refreshIcebergChart();
        }
      } else {
        tradersSection.classList.add("active");
        accountSection.classList.remove("active");
        chartSection.classList.remove("active");
        tabTraders.classList.add("active");
        tabAccount.classList.remove("active");
        tabChart.classList.remove("active");
        if (state.selected) {
          fetchHistory(state.selected);
          refreshSignals(state.selected, state.selectedLabel || state.selectedSymbol);
        }
      }
    }

    function formatPosition(pos) {
      if (!pos) return "--";
      const side = pos.side || "Flat";
      const size = pos.size ? Number(pos.size).toFixed(4) : "0.0000";
      return `${side} ${size}`;
    }

    function selectSymbol(key) {
      state.selected = key;
      const item = key ? state.latestMap[key] : null;
      const symbol = item?.symbol || key || null;
      state.selectedSymbol = symbol;
      state.selectedLabel = displayNameFor(key, symbol);
      renderSummary(state.items);
      if (key) {
        fetchHistory(key);
        refreshSignals(key, state.selectedLabel || state.selectedSymbol);
      }
    }

    function updateDetail(data) {
      if (!data) return;
      const key = entryKey(data);
      if (!key) return;
      const symbol = data.symbol || key;
      state.selected = key;
      state.selectedSymbol = symbol;
      const pos = data.position || {};
      const health = data.health || {};
      const latency = data.latency || {};
      const orders = data.orders || {};
      const rec = orders.last_reconcile || {};
      const drift = data.drift || {};
      const errors = data.errors || {};
      const dataHealth = data.data_health || {};
      const prediction = data.prediction || health.last_prediction || {};
      const model = data.model || {};
      const featureVector = data.feature_vector || {};

      const alias = aliasForKey(key);
      const displayName = alias || symbol;
      state.selectedLabel = displayName;
      const tagParts = [];
      if (alias && alias !== symbol) {
        tagParts.push(symbol);
      }
      if (key && key !== symbol && key !== alias) {
        tagParts.push(key);
      }
      const tagText = tagParts.length ? ` (${tagParts.join(" / ")})` : "";
      const modelText = modelLabel(data);
      const modelTag = modelText && modelText !== "--" ? ` | Model: ${modelText}` : "";
      document.getElementById("detailTitle").textContent = `Selected: ${displayName}${tagText}`;
      document.getElementById("detailSub").textContent = `Startup: ${data.startup_time || "--"} | Uptime: ${Math.round(data.uptime_sec || 0)}s | Last: ${data.ts || "--"}${modelTag}`;
      syncAliasControls(key, symbol);
      const detailStatus = document.getElementById("detailStatus");
      if (data.signal_only) {
        detailStatus.textContent = "Signal Only";
        detailStatus.className = "pill signal";
      } else {
        detailStatus.textContent = data.trade_enabled ? "Trading Enabled" : "Trading Paused";
        detailStatus.className = "pill " + (data.trade_enabled ? "ok" : "warn");
      }

      document.getElementById("equityVal").textContent = data.equity ? fmt(data.equity, 4) : "--";
      document.getElementById("dailyPnl").textContent = fmt(data.daily_pnl, 4);
      document.getElementById("unrealPnl").textContent = fmt(pos.unreal_pnl, 4);

      document.getElementById("posSide").textContent = pos.side || "--";
      document.getElementById("posSize").textContent = fmt(pos.size, 4);
      document.getElementById("posEntry").textContent = fmt(pos.entry_price, 6);
      document.getElementById("posMark").textContent = fmt(pos.mark_price, 6);
      document.getElementById("posTPSL").textContent = `${fmt(pos.take_profit, 6)} / ${fmt(pos.stop_loss, 6)}`;

      const healthEl = document.getElementById("healthVal");
      healthEl.textContent = health.status || "--";
      healthEl.className = "value " + healthClass(health.status);
      document.getElementById("sentimentVal").textContent = health.sentiment || "--";
      document.getElementById("regimeVal").textContent = health.regime || "--";
      document.getElementById("tradeEnabled").textContent = data.signal_only ? "Signal Only" : (data.trade_enabled ? "Yes" : "No");
      const driftText = drift.alerts && drift.alerts.length ? drift.alerts.join(", ") : "None";
      document.getElementById("driftAlerts").textContent = driftText;

      document.getElementById("barsVal").textContent = dataHealth.bars || 0;
      document.getElementById("macroPct").textContent = fmtPct(dataHealth.macro_pct);
      document.getElementById("obDensity").textContent = fmtPct(dataHealth.ob_density_pct);
      document.getElementById("tradeCont").textContent = dataHealth.trade_cont ?? "--";
      document.getElementById("lagTradeBar").textContent = `${fmtSec(latency.lag_trade_sec)} / ${fmtSec(latency.lag_bar_sec)}`;

      document.getElementById("restLatency").textContent = fmtMs(latency.rest_avg_ms);
      document.getElementById("wsTrade").textContent = fmtMs(latency.ws_trade_ms);
      document.getElementById("wsOb").textContent = fmtMs(latency.ws_ob_ms);
      document.getElementById("obLag").textContent = fmtSec(latency.ob_lag_sec);

      document.getElementById("openOrders").textContent = orders.open_orders ?? 0;
      document.getElementById("lastReconcile").textContent = rec.ts || "--";
      document.getElementById("reconcileSource").textContent = rec.source || "--";
      document.getElementById("protectiveCount").textContent = rec.protective_orders ?? "--";

      document.getElementById("errorCount").textContent = `${errors.runtime_count ?? 0} / ${errors.api_count ?? 0}`;
      document.getElementById("lastRuntime").textContent = errors.last_runtime_error || "--";
      document.getElementById("lastApi").textContent = errors.last_api_error || "--";

      const predLong = prediction.pred_long;
      const predShort = prediction.pred_short;
      document.getElementById("modelPred").textContent = `${fmt(predLong, 3)} / ${fmt(predShort, 3)}`;
      document.getElementById("predLong").textContent = fmt(predLong, 3);
      document.getElementById("predShort").textContent = fmt(predShort, 3);
      document.getElementById("predThreshold").textContent = fmt(prediction.threshold, 3);
      document.getElementById("predBar").textContent = prediction.bar_time ?? "--";

      const direction = data.direction || {};
      const dirThreshold = direction.threshold;
      const dirAggressive = direction.aggressive_threshold;
      setDirectionValue("dirLong", direction.pred_long, dirThreshold, dirAggressive, "long");
      setDirectionValue("dirShort", direction.pred_short, dirThreshold, dirAggressive, "short");
      const dirThresholdEl = document.getElementById("dirThreshold");
      if (dirThresholdEl) {
        dirThresholdEl.textContent = fmt(dirThreshold, 3);
        dirThresholdEl.className = "muted";
      }
      const dirAggressiveEl = document.getElementById("dirAggressive");
      if (dirAggressiveEl) {
        dirAggressiveEl.textContent = fmt(dirAggressive, 3);
        dirAggressiveEl.className = "muted";
      }
      const dirBarEl = document.getElementById("dirBar");
      if (dirBarEl) dirBarEl.textContent = direction.bar_time ?? "--";

      const modelPath = model.dir || "--";
      const modelPathEl = document.getElementById("modelPath");
      modelPathEl.textContent = modelPath;
      modelPathEl.title = modelPath;
      document.getElementById("keysProfile").textContent = model.keys_profile || "--";

      const signalInfo = data.signal || {};
      const signalItems = Array.isArray(signalInfo.signals) ? signalInfo.signals : [];
      const normalizedSignals = normalizeSignals(signalItems);
      const activeSignal = pickDominantSignal(normalizedSignals);
      const signalStatusEl = document.getElementById("signalStatus");
      if (activeSignal) {
        const sideKey = signalSideKey(activeSignal.side);
        signalStatusEl.textContent = sideKey === "short" ? "Signal Short" : "Signal Long";
        signalStatusEl.className = "value " + (sideKey === "short" ? "bad" : "ok");
        document.getElementById("signalSide").textContent = signalSideLabel(activeSignal.side);
        document.getElementById("signalEntry").textContent = formatSignalPrice(activeSignal.entry_price || activeSignal.target, activeSignal.tick_size);
        document.getElementById("signalTP").textContent = formatSignalPrice(activeSignal.tp, activeSignal.tick_size);
        document.getElementById("signalSL").textContent = formatSignalPrice(activeSignal.sl, activeSignal.tick_size);
        document.getElementById("signalTime").textContent = formatSignalTime(activeSignal);
      } else {
        signalStatusEl.textContent = "No Signal";
        signalStatusEl.className = "value muted";
        document.getElementById("signalSide").textContent = "--";
        document.getElementById("signalEntry").textContent = "--";
        document.getElementById("signalTP").textContent = "--";
        document.getElementById("signalSL").textContent = "--";
        document.getElementById("signalTime").textContent = "--";
      }

      renderFeatures(featureVector);
    }

    function renderFeatures(featureVector) {
      const container = document.getElementById("featureList");
      container.innerHTML = "";
      const names = featureVector.names || [];
      const values = featureVector.values || [];
      if (!names.length || !values.length) {
        container.textContent = "--";
        return;
      }
      for (let i = 0; i < names.length; i++) {
        const item = document.createElement("div");
        item.className = "feature-item";
        item.textContent = `${names[i]}: ${fmt(values[i], 6)}`;
        container.appendChild(item);
      }
    }

    function normalizeSignals(list) {
      if (!Array.isArray(list)) return [];
      return list.map(sig => {
        const barTime = Number(sig.bar_time || 0);
        const entry = Number(sig.entry_price || sig.target || 0);
        const tickSize = Number(sig.tick_size || 0);
        const rawTp = Number(sig.tp || 0);
        const rawSl = Number(sig.sl || 0);
        let tp = Number.isFinite(rawTp) ? rawTp : 0;
        let sl = Number.isFinite(rawSl) ? rawSl : 0;
        const needsTp = tp <= 0;
        const needsSl = sl <= 0;
        if ((needsTp || needsSl) && entry > 0) {
          const computed = computeSignalTargets(sig, entry);
          if (needsTp) tp = computed.tp;
          if (needsSl) sl = computed.sl;
        }
        return {
          ...sig,
          id: sig.id || `${barTime}-${sig.side || ""}-${entry}`,
          bar_time: barTime,
          entry_price: entry,
          tick_size: tickSize,
          tp,
          sl,
          pred: Number(sig.pred || 0)
        };
      }).filter(sig => sig.bar_time > 0 && sig.entry_price > 0);
    }

    function normalizeCandles(payload) {
      const list = Array.isArray(payload) ? payload : (payload?.candles || []);
      return list.map(c => ({
        time: Number(c.time || 0),
        open: Number(c.open || 0),
        high: Number(c.high || 0),
        low: Number(c.low || 0),
        close: Number(c.close || 0)
      })).filter(c => c.time > 0 && c.open > 0 && c.high > 0 && c.low > 0 && c.close > 0)
        .sort((a, b) => a.time - b.time);
    }

    function loadSignalChartLib(callback) {
      if (window.echarts) {
        callback();
        return;
      }
      if (state.signalChartLoading) {
        setTimeout(() => loadSignalChartLib(callback), 200);
        return;
      }
      state.signalChartLoading = true;
      const script = document.createElement("script");
      script.src = "/static/echarts.min.js";
      script.onload = () => {
        state.signalChartLoading = false;
        callback();
      };
      script.onerror = () => {
        state.signalChartLoading = false;
        const sub = document.getElementById("signalSub");
        if (sub) sub.textContent = "Signal chart library failed to load.";
      };
      document.head.appendChild(script);
    }

    function initSignalChart() {
      if (!window.echarts) return false;
      const container = document.getElementById("signalChart");
      if (!container || container.clientWidth <= 0 || container.clientHeight <= 0) return false;
      if (!state.signalChart) {
        state.signalChart = window.echarts.init(container, null, { renderer: "canvas", useDirtyRect: true });
        window.addEventListener("resize", () => {
          if (state.signalChart) {
            state.signalChart.resize();
          }
        });
      }
      if (state.signalChart && !state.signalZoomBound) {
        state.signalChart.on("datazoom", (evt) => {
          const batch = Array.isArray(evt?.batch) && evt.batch.length ? evt.batch[0] : evt;
          const start = Number(batch?.start);
          const end = Number(batch?.end);
          if (Number.isFinite(start) && Number.isFinite(end)) {
            state.signalZoom = { start, end };
            state.signalZoomActive = true;
          }
        });
        state.signalZoomBound = true;
      }
      return true;
    }

    function renderSignalChart() {
      if (!state.selected) return;
      if (!window.echarts) {
        loadSignalChartLib(renderSignalChart);
        return;
      }
      if (!initSignalChart()) return;

      const candles = state.signalCandles || [];
      const signals = state.signalHistory || [];
      const sub = document.getElementById("signalSub");
      if (!candles.length) {
        if (sub) sub.textContent = "Waiting for candle data...";
        state.signalChart.clear();
        return;
      }

      const categories = [];
      const candleData = [];
      const indexMap = new Map();
      candles.forEach((candle, idx) => {
        indexMap.set(candle.time, idx);
        const label = new Date(candle.time * 1000).toLocaleString();
        categories.push(label);
        candleData.push([candle.open, candle.close, candle.low, candle.high]);
      });

      const focusId = state.signalFocusId;
      const visibleSignals = focusId ? signals.filter(sig => sig.id === focusId) : signals;
      const longPoints = [];
      const shortPoints = [];
      const directionPoints = [];
      const normalizeBarTime = (value) => {
        const num = Number(value || 0);
        if (!Number.isFinite(num) || num <= 0) return null;
        return num > 1e12 ? Math.floor(num / 1000) : Math.floor(num);
      };
      const findBarIndex = (barTime) => {
        if (!barTime || !candles.length) return null;
        if (indexMap.has(barTime)) return indexMap.get(barTime);
        for (let i = candles.length - 1; i >= 0; i--) {
          if (candles[i].time <= barTime) return i;
        }
        return null;
      };
      const addDirectionPoint = (side, pred, threshold, aggressiveThreshold, barTime) => {
        if (!Number.isFinite(pred) || !Number.isFinite(threshold) || !Number.isFinite(aggressiveThreshold)) return;
        const aggressive = pred >= aggressiveThreshold;
        const normal = pred >= threshold;
        if (!normal && !aggressive) return;
        const idx = findBarIndex(barTime);
        if (idx === null || idx === undefined) return;
        const candle = candles[idx] || {};
        const basePrice = Number(candle.close || candle.open || 0);
        if (!Number.isFinite(basePrice) || basePrice <= 0) return;
        const offset = basePrice * 0.0015;
        const price = side === "short" ? basePrice - offset : basePrice + offset;
        const baseThreshold = aggressive ? aggressiveThreshold : threshold;
        const span = Number.isFinite(baseThreshold) ? Math.max(0.0001, 1 - baseThreshold) : 1;
        const strength = Number.isFinite(baseThreshold) ? Math.max(0, Math.min(1, (pred - baseThreshold) / span)) : 0;
        const size = 10 + Math.round(strength * 10) + (aggressive ? 8 : 0);
        const color = aggressive
          ? (side === "short" ? "#ec4899" : "#0ea5e9")
          : (side === "short" ? "#f472b6" : "#38bdf8");
        directionPoints.push({
          value: [idx, price],
          direction: {
            side,
            pred,
            aggressive
          },
          symbol: aggressive ? "diamond" : "circle",
          symbolSize: size,
          itemStyle: {
            color
          }
        });
      };

      const directionHistory = (state.directionKey === state.signalKey) ? (state.directionHistory || []) : [];
      const dirEntries = new Map();
      const recordDirection = (barTime, payload, tsMs) => {
        if (!barTime) return;
        const existing = dirEntries.get(barTime);
        if (!existing || (tsMs && tsMs >= (existing.tsMs || 0))) {
          dirEntries.set(barTime, { ...payload, barTime, tsMs: tsMs || 0 });
        }
      };

      if (Array.isArray(directionHistory) && directionHistory.length) {
        directionHistory.forEach(item => {
          const dir = item && item.direction ? item.direction : {};
          if (!dir) return;
          const barTime = normalizeBarTime(dir.bar_time || item.market?.last_bar_time || item.bar_time);
          const tsMs = item.ts ? (parseTs(String(item.ts)) || 0) : 0;
          recordDirection(barTime, {
            predLong: numOrNaN(dir.pred_long),
            predShort: numOrNaN(dir.pred_short),
            threshold: numOrNaN(dir.threshold),
            aggressiveThreshold: numOrNaN(dir.aggressive_threshold)
          }, tsMs);
        });
      } else {
        const latestItem = state.latestMap ? state.latestMap[state.selected] : null;
        const direction = latestItem && latestItem.direction ? latestItem.direction : {};
        const barTime = normalizeBarTime(direction.bar_time);
        recordDirection(barTime, {
          predLong: numOrNaN(direction.pred_long),
          predShort: numOrNaN(direction.pred_short),
          threshold: numOrNaN(direction.threshold),
          aggressiveThreshold: numOrNaN(direction.aggressive_threshold)
        }, 0);
      }

      dirEntries.forEach(entry => {
        addDirectionPoint("long", entry.predLong, entry.threshold, entry.aggressiveThreshold, entry.barTime);
        addDirectionPoint("short", entry.predShort, entry.threshold, entry.aggressiveThreshold, entry.barTime);
      });
      visibleSignals.forEach(sig => {
        const idx = indexMap.get(sig.bar_time);
        if (idx === undefined) return;
        const side = signalSideKey(sig.side);
        const style = signalMarkerStyle(side === "short" ? "short" : "long", sig.pred);
        const payload = {
          value: [idx, sig.entry_price],
          signal: sig,
          symbolSize: style.size,
          itemStyle: {
            color: style.color,
            borderColor: style.borderColor,
            borderWidth: style.borderWidth,
            shadowBlur: style.shadowBlur,
            shadowColor: style.shadowColor
          }
        };
        if (side === "short") {
          shortPoints.push(payload);
        } else {
          longPoints.push(payload);
        }
      });

      let focusSignal = null;
      if (focusId) {
        focusSignal = signals.find(sig => sig.id === focusId) || null;
      }
      const markLineData = [];
      if (focusSignal) {
        if (focusSignal.entry_price > 0) {
          markLineData.push({ yAxis: focusSignal.entry_price, name: "Entry" });
        }
        if (focusSignal.tp > 0) {
          markLineData.push({ yAxis: focusSignal.tp, name: "TP" });
        }
        if (focusSignal.sl > 0) {
          markLineData.push({ yAxis: focusSignal.sl, name: "SL" });
        }
      }
      const zoom = state.signalZoomActive ? state.signalZoom : null;
      const zoomStart = Number.isFinite(zoom?.start) ? zoom.start : 70;
      const zoomEnd = Number.isFinite(zoom?.end) ? zoom.end : 100;
      const markTick = focusSignal ? focusSignal.tick_size : 0;

      const option = {
        backgroundColor: "transparent",
        grid: { left: 50, right: 20, top: 20, bottom: 50 },
        tooltip: {
          trigger: "axis",
          axisPointer: { type: "cross" },
          formatter: (params) => {
            const items = Array.isArray(params) ? params : [params];
            let header = "";
            let candleInfo = "";
            let signalInfo = "";
            let directionInfo = "";
            items.forEach(item => {
              if (item.seriesType === "candlestick") {
                header = item.name || "";
                const val = item.data || [];
                candleInfo = `O:${fmt(val[0], 6)} H:${fmt(val[3], 6)} L:${fmt(val[2], 6)} C:${fmt(val[1], 6)}`;
              }
              if (item.data && item.data.signal) {
                const sig = item.data.signal;
                signalInfo = [
                  `Signal: ${signalSideLabel(sig.side)} (${fmt(sig.pred, 3)})`,
                  `Entry: ${formatSignalPrice(sig.entry_price, sig.tick_size)}`,
                  `TP: ${formatSignalPrice(sig.tp, sig.tick_size)} | SL: ${formatSignalPrice(sig.sl, sig.tick_size)}`,
                  `Time: ${formatSignalTime(sig)}`
                ].join("<br/>");
              }
              if (item.data && item.data.direction) {
                const dir = item.data.direction;
                const tag = dir.aggressive ? "AGG" : "DIR";
                directionInfo = `${tag} ${signalSideLabel(dir.side)} (${fmt(dir.pred, 3)})`;
              }
            });
            return [header, candleInfo, signalInfo, directionInfo].filter(Boolean).join("<br/>");
          }
        },
        xAxis: {
          type: "category",
          data: categories,
          boundaryGap: true,
          axisLine: { lineStyle: { color: "rgba(148,163,184,0.3)" } },
          axisLabel: { color: "#94a3b8" }
        },
        yAxis: {
          scale: true,
          axisLine: { lineStyle: { color: "rgba(148,163,184,0.3)" } },
          axisLabel: { color: "#94a3b8" },
          splitLine: { lineStyle: { color: "rgba(148,163,184,0.12)" } }
        },
        dataZoom: [
          { type: "inside", start: zoomStart, end: zoomEnd },
          {
            type: "slider",
            start: zoomStart,
            end: zoomEnd,
            height: 20,
            bottom: 12,
            borderColor: "rgba(148,163,184,0.2)",
            textStyle: { color: "#94a3b8" }
          }
        ],
        series: [
          {
            name: "Price",
            type: "candlestick",
            data: candleData,
            itemStyle: {
              color: "#22c55e",
              color0: "#ef4444",
              borderColor: "#22c55e",
              borderColor0: "#ef4444"
            },
            markLine: markLineData.length ? {
              symbol: "none",
              lineStyle: { color: "#38bdf8", type: "dashed", opacity: 0.8 },
              label: {
                color: "#e2e8f0",
                formatter: (p) => `${p.name}: ${formatSignalPrice(p.value, markTick)}`
              },
              data: markLineData
            } : undefined
          },
          {
            name: "Direction",
            type: "scatter",
            data: directionPoints,
            symbol: "circle",
            symbolSize: (val, params) => (params && params.data && params.data.symbolSize) ? params.data.symbolSize : 10,
            itemStyle: { color: "#38bdf8" },
            label: { show: false }
          },
          {
            name: "Signal Long",
            type: "scatter",
            data: longPoints,
            symbol: "triangle",
            symbolSize: (val, params) => (params && params.data && params.data.symbolSize) ? params.data.symbolSize : 12,
            itemStyle: { color: "#22c55e" },
            label: {
              show: Boolean(focusId),
              formatter: (p) => formatSignalTime(p.data.signal),
              color: "#e2e8f0",
              fontSize: 10,
              offset: [0, -12]
            }
          },
          {
            name: "Signal Short",
            type: "scatter",
            data: shortPoints,
            symbol: "triangle",
            symbolSize: (val, params) => (params && params.data && params.data.symbolSize) ? params.data.symbolSize : 12,
            symbolRotate: 180,
            itemStyle: { color: "#ef4444" },
            label: {
              show: Boolean(focusId),
              formatter: (p) => formatSignalTime(p.data.signal),
              color: "#e2e8f0",
              fontSize: 10,
              offset: [0, 12]
            }
          }
        ]
      };

      state.signalChart.setOption(option, { notMerge: true, lazyUpdate: true });
      if (sub && state.signalSymbol) {
        sub.textContent = `${state.signalSymbol} | Signals: ${signals.length} | Showing: ${visibleSignals.length}`;
      }
    }

    function renderSignalList() {
      const listEl = document.getElementById("signalList");
      if (!listEl) return;
      listEl.innerHTML = "";
      const signals = state.signalHistory || [];
      if (!signals.length) {
        listEl.textContent = "--";
        const clearBtn = document.getElementById("signalClear");
        if (clearBtn) {
          clearBtn.classList.remove("active");
        }
        return;
      }
      const focusId = state.signalFocusId;
      const visible = focusId ? signals.filter(sig => sig.id === focusId) : signals;
      if (!visible.length) {
        listEl.textContent = "--";
        return;
      }
      const sorted = [...visible].sort((a, b) => (signalTimestampMs(b) || 0) - (signalTimestampMs(a) || 0));
      sorted.forEach(sig => {
        const sideKey = signalSideKey(sig.side);
        const item = document.createElement("div");
        item.className = [
          "signal-item",
          sideKey === "short" ? "short" : "",
          state.signalFocusId === sig.id ? "active" : ""
        ].join(" ").trim();
        item.addEventListener("click", () => {
          if (state.signalFocusId === sig.id) {
            state.signalFocusId = null;
          } else {
            state.signalFocusId = sig.id;
          }
          renderSignalList();
          renderSignalChart();
        });

        const top = document.createElement("div");
        top.className = "signal-side " + (sideKey || "long");
        top.textContent = `${signalSideLabel(sig.side)} signal`;

        const meta = document.createElement("div");
        meta.className = "signal-meta";
        meta.textContent = `${formatSignalTime(sig)} | Pred ${fmt(sig.pred, 3)}`;

        const values = document.createElement("div");
        values.className = "signal-values";
        values.innerHTML = `
          <div><strong>${formatSignalPrice(sig.entry_price, sig.tick_size)}</strong><span>Entry Price</span></div>
          <div><strong>${formatSignalPrice(sig.tp, sig.tick_size)}</strong><span>TP Price</span></div>
          <div><strong>${formatSignalPrice(sig.sl, sig.tick_size)}</strong><span>SL Price</span></div>
        `;

        item.appendChild(top);
        item.appendChild(meta);
        item.appendChild(values);
        listEl.appendChild(item);
      });

      const clearBtn = document.getElementById("signalClear");
      if (clearBtn) {
        clearBtn.classList.toggle("active", Boolean(state.signalFocusId));
      }
    }

    async function fetchSignals(key) {
      if (!key) return;
      const resp = await fetch(`/api/signals?key=${encodeURIComponent(key)}&limit=80`);
      if (!resp.ok) return;
      const data = await resp.json();
      state.signalHistory = normalizeSignals(data || []);
      syncSignalCache();
      renderSignalList();
      if (state.signalCandles && state.signalCandles.length) {
        renderSignalChart();
      }
    }

    async function fetchSignalCandles(key) {
      if (!key) return;
      const resp = await fetch(`/api/candles?key=${encodeURIComponent(key)}&limit=500`);
      if (!resp.ok) return;
      const payload = await resp.json();
      state.signalCandles = normalizeCandles(payload);
      syncSignalCache();
      renderSignalChart();
    }

    function stashSignalCache(key) {
      if (!key) return;
      state.signalCache[key] = {
        signalHistory: Array.isArray(state.signalHistory) ? [...state.signalHistory] : [],
        signalCandles: Array.isArray(state.signalCandles) ? [...state.signalCandles] : [],
        signalFocusId: state.signalFocusId,
        signalZoom: state.signalZoom ? { ...state.signalZoom } : null,
        signalZoomActive: state.signalZoomActive,
        signalZoomBound: state.signalZoomBound,
        signalLastCandleFetch: state.signalLastCandleFetch,
        directionHistory: Array.isArray(state.directionHistory) ? [...state.directionHistory] : [],
        directionKey: state.directionKey
      };
    }

    function restoreSignalCache(key) {
      if (!key) return false;
      const cached = state.signalCache[key];
      if (!cached) return false;
      state.signalHistory = cached.signalHistory || [];
      state.signalCandles = cached.signalCandles || [];
      state.signalFocusId = cached.signalFocusId || null;
      state.signalZoom = cached.signalZoom || null;
      state.signalZoomActive = Boolean(cached.signalZoomActive);
      state.signalZoomBound = Boolean(cached.signalZoomBound);
      state.signalLastCandleFetch = cached.signalLastCandleFetch || 0;
      state.directionHistory = cached.directionHistory || [];
      state.directionKey = cached.directionKey || key;
      return true;
    }

    function syncSignalCache() {
      if (!state.signalKey) return;
      stashSignalCache(state.signalKey);
    }

    function refreshSignals(key, symbol) {
      if (!key) return;
      if (state.signalKey !== key) {
        if (state.signalKey) {
          stashSignalCache(state.signalKey);
        }
        state.signalKey = key;
        state.signalSymbol = symbol || key;
        const restored = restoreSignalCache(key);
        if (!restored) {
          state.signalFocusId = null;
          state.signalCandles = [];
          state.signalHistory = [];
          state.signalZoom = null;
          state.signalZoomActive = false;
          state.signalZoomBound = false;
          state.directionHistory = [];
          state.directionKey = null;
          if (state.signalChart) {
            state.signalChart.clear();
          }
          const sub = document.getElementById("signalSub");
          if (sub) sub.textContent = "Loading candle data...";
        } else {
          renderSignalChart();
        }
      }
      const now = Date.now();
      if (!state.signalLastCandleFetch || (now - state.signalLastCandleFetch) > 20000) {
        state.signalLastCandleFetch = now;
        fetchSignalCandles(key);
      }
      fetchSignals(key);
    }

    function renderProfiles(list) {
      const container = document.getElementById("accountProfiles");
      container.innerHTML = "";
      if (!Array.isArray(list) || !list.length) {
        container.textContent = "--";
        return;
      }
      const filtered = filterHistory(state.balanceHistory, state.balanceRange);
      const seriesMap = {};
      filtered.forEach(item => {
        if (!item || !Array.isArray(item.profiles)) return;
        item.profiles.forEach(p => {
          if (!p || !p.name) return;
          if (!seriesMap[p.name]) seriesMap[p.name] = [];
          seriesMap[p.name].push(Number(p.total_equity || 0));
        });
      });
      list.forEach(item => {
        const row = document.createElement("div");
        row.className = "profile-row";
        const left = document.createElement("div");
        left.className = "profile-meta";
        const name = document.createElement("span");
        name.textContent = item.name || "--";
        const sub = document.createElement("span");
        const unified = item.unified_equity ? fmt(item.unified_equity, 4) : "--";
        const funding = item.funding_equity ? fmt(item.funding_equity, 4) : "--";
        const fundingErr = item.funding_error ? ` | Funding: ${item.funding_error}` : "";
        sub.textContent = `U:${unified} / F:${funding}${fundingErr}`;
        left.appendChild(name);
        left.appendChild(sub);

        const right = document.createElement("div");
        right.className = "profile-metrics";
        const total = item.total_equity ? fmt(item.total_equity, 4) : "--";
        const totalEl = document.createElement("span");
        totalEl.textContent = total;
        const canvas = document.createElement("canvas");
        canvas.className = "profile-spark";
        canvas.dataset.profile = item.name || "";
        right.appendChild(totalEl);
        right.appendChild(canvas);
        row.appendChild(left);
        row.appendChild(right);
        container.appendChild(row);

        const series = seriesMap[item.name] || [];
        const trimmed = series.slice(-80).filter(v => v > 0);
        sparkline(canvas, trimmed, "#38bdf8");
      });
    }

    function updateBalances(data) {
      if (!data) return;
      state.balanceLatest = data;
      const stats = data.stats || {};
      const total = Number(data.total_equity || 0);
      const unified = Number(data.total_unified || 0);
      const funding = Number(data.total_funding || 0);
      const available = Number(data.total_available || 0);
      document.getElementById("aggBalance").textContent = total ? fmt(total, 4) : "--";
      document.getElementById("aggAvailable").textContent = available ? fmt(available, 4) : "--";
      document.getElementById("aggProfiles").textContent = data.profile_count ?? "--";
      document.getElementById("aggUnified").textContent = unified ? fmt(unified, 4) : "--";
      document.getElementById("aggFunding").textContent = funding ? fmt(funding, 4) : "--";
      document.getElementById("aggUnifiedShare").textContent = total ? `${fmt((unified / total) * 100, 1)}%` : "--";
      document.getElementById("aggFundingShare").textContent = total ? `${fmt((funding / total) * 100, 1)}%` : "--";
      document.getElementById("aggUpdated").textContent = data.ts || "--";
      document.getElementById("aggFlows").textContent = stats.flow_events ?? "--";
      const fundingStatus = document.getElementById("aggFundingStatus");
      if (fundingStatus) {
        fundingStatus.textContent = data.funding_error ? data.funding_error : "OK";
        fundingStatus.className = data.funding_error ? "bad" : "ok";
      }

      const accountSub = document.getElementById("accountSub");
      if (accountSub) {
        accountSub.textContent = `Total (Unified + Funding): ${total ? fmt(total, 4) : "--"} | Updated: ${data.ts || "--"}`;
      }
      const accountStatus = document.getElementById("accountStatus");
      if (accountStatus) {
        accountStatus.textContent = data.funding_error ? "Funding Error" : (total > 0 ? "Live" : "No Data");
      }

      document.getElementById("aggReturn").textContent = stats.total_return_pct === null || stats.total_return_pct === undefined
        ? "--"
        : `${fmt(stats.total_return_pct, 2)}%`;
      document.getElementById("aggMaxDD").textContent = stats.max_drawdown_pct === null || stats.max_drawdown_pct === undefined
        ? "--"
        : `${fmt(stats.max_drawdown_pct, 2)}%`;
      document.getElementById("aggVolatility").textContent = stats.volatility_pct === null || stats.volatility_pct === undefined
        ? "--"
        : `${fmt(stats.volatility_pct, 2)}%`;
      document.getElementById("aggStability").textContent = stats.stability_pct === null || stats.stability_pct === undefined
        ? "--"
        : `${fmt(stats.stability_pct, 1)}%`;
      document.getElementById("aggSmoothness").textContent = stats.smoothness_r2 === null || stats.smoothness_r2 === undefined
        ? "--"
        : fmt(stats.smoothness_r2, 2);
      document.getElementById("aggTrend").textContent = stats.slope_per_day === null || stats.slope_per_day === undefined
        ? "--"
        : fmt(stats.slope_per_day, 4);
      document.getElementById("aggRawReturn").textContent = stats.raw_total_return_pct === null || stats.raw_total_return_pct === undefined
        ? "--"
        : `${fmt(stats.raw_total_return_pct, 2)}%`;
      document.getElementById("aggPoints").textContent = stats.points ?? "--";

      if (stats.flow_threshold_pct) {
        state.balanceFlowPct = stats.flow_threshold_pct;
        const note = document.getElementById("balanceNote");
        if (note) {
          note.textContent = `Flow threshold: ${fmt(stats.flow_threshold_pct, 1)}% (large deposits/withdrawals removed).`;
        }
      }
      renderProfiles(data.profiles || []);
      renderBalanceHistory();
    }

    async function fetchBalances() {
      const resp = await fetch("/api/balances");
      if (!resp.ok) return;
      const data = await resp.json();
      updateBalances(data);
    }

    function renderBalanceHistory() {
      const filtered = filterHistory(state.balanceHistory, state.balanceRange);
      const raw = [];
      const labels = [];
      filtered.forEach(item => {
        const val = Number(item.total_equity || 0);
        if (val > 0) {
          raw.push(val);
          labels.push(item.ts);
        }
      });
      const { adjusted, flowEvents } = computeAdjustedSeries(raw, state.balanceFlowPct);
      state.balancePlot = { raw, adjusted, labels, flowEvents };
      drawBalanceChart(
        document.getElementById("balanceChart"),
        raw,
        adjusted,
        state.balanceScale,
        state.balanceShowRaw,
        state.balanceShowAdjusted,
      );
      if (state.balanceLatest) {
        renderProfiles(state.balanceLatest.profiles || []);
      }
      updateLegendVisibility();
    }

    function updateLegendVisibility() {
      const rawLabel = document.querySelector(".legend .raw");
      const adjLabel = document.querySelector(".legend .adjusted");
      if (rawLabel) {
        rawLabel.classList.toggle("inactive", !state.balanceShowRaw);
      }
      if (adjLabel) {
        adjLabel.classList.toggle("inactive", !state.balanceShowAdjusted);
      }
    }

    async function fetchBalanceHistory() {
      const resp = await fetch("/api/balance_history?limit=10000");
      if (!resp.ok) return;
      const data = await resp.json();
      const sorted = (data || []).slice().sort((a, b) => {
        const ta = parseTs(a?.ts) || 0;
        const tb = parseTs(b?.ts) || 0;
        return ta - tb;
      });
      state.balanceHistory = sorted;
      renderBalanceHistory();
    }

    async function fetchSummary() {
      const resp = await fetch("/api/summary");
      if (!resp.ok) return;
      const items = await resp.json();
      renderSummary(items || []);
    }

    async function fetchHistory(key) {
      if (!key) return;
      const resp = await fetch(`/api/metrics?key=${encodeURIComponent(key)}&limit=200`);
      if (!resp.ok) return;
      const data = await resp.json();
      if (Array.isArray(data)) {
        state.directionHistory = data;
        state.directionKey = key;
        syncSignalCache();
      }
      const equity = data.map(x => Number(x.equity || 0));
      const latency = data.map(x => Number(x.latency?.rest_avg_ms || 0));
      sparkline(document.getElementById("equityChart"), equity, "#22c55e");
      sparkline(document.getElementById("latencyChart"), latency, "#f59e0b");
      state.lastHistoryKey = key;
    }

    fetchSummary();
    fetchBalances();
    fetchBalanceHistory();
    setupBalanceTooltip();
    setInterval(fetchSummary, 2000);
    setInterval(fetchBalances, 5000);
    setInterval(fetchBalanceHistory, 15000);
    setInterval(() => {
      if (state.selected) {
        fetchHistory(state.selected);
      }
    }, 10000);
    setInterval(() => {
      if (state.selected) {
        refreshSignals(state.selected, state.selectedLabel || state.selectedSymbol);
      }
    }, 6000);

    document.getElementById("tabAccount").addEventListener("click", () => setView("account"));
    document.getElementById("tabTraders").addEventListener("click", () => setView("traders"));
    document.getElementById("tabChart").addEventListener("click", () => setView("chart"));
    const aliasInput = document.getElementById("aliasInput");
    const aliasSave = document.getElementById("aliasSave");
    const aliasClear = document.getElementById("aliasClear");
    const commitAlias = () => {
      if (!aliasInput) return;
      const key = aliasInput.dataset.aliasKey || state.selected;
      if (!key) return;
      const alias = normalizeAlias(aliasInput.value);
      setAliasForKey(key, alias);
      renderSummary(state.items);
    };
    if (aliasSave) {
      aliasSave.addEventListener("click", commitAlias);
    }
    if (aliasClear) {
      aliasClear.addEventListener("click", () => {
        if (!aliasInput) return;
        const key = aliasInput.dataset.aliasKey || state.selected;
        if (!key) return;
        aliasInput.value = "";
        setAliasForKey(key, "");
        renderSummary(state.items);
      });
    }
    if (aliasInput) {
      aliasInput.addEventListener("keydown", (event) => {
        if (event.key === "Enter") {
          commitAlias();
        }
      });
    }
    syncAliasControls(null, null);
    const signalClearBtn = document.getElementById("signalClear");
    if (signalClearBtn) {
      signalClearBtn.addEventListener("click", () => {
        state.signalFocusId = null;
        renderSignalList();
        renderSignalChart();
      });
    }

    document.querySelectorAll("#balanceRange .range-btn").forEach(btn => {
      btn.addEventListener("click", () => {
        document.querySelectorAll("#balanceRange .range-btn").forEach(b => b.classList.remove("active"));
        btn.classList.add("active");
        state.balanceRange = btn.dataset.range || "all";
        renderBalanceHistory();
      });
    });

    document.querySelectorAll("#balanceScale .range-btn").forEach(btn => {
      btn.addEventListener("click", () => {
        document.querySelectorAll("#balanceScale .range-btn").forEach(b => b.classList.remove("active"));
        btn.classList.add("active");
        state.balanceScale = btn.dataset.scale || "shared";
        renderBalanceHistory();
      });
    });

    document.querySelectorAll("#balanceToggle .toggle-btn").forEach(btn => {
      btn.addEventListener("click", () => {
        const type = btn.dataset.toggle;
        if (!type) return;
        const key = type === "raw" ? "balanceShowRaw" : "balanceShowAdjusted";
        state[key] = !state[key];
        btn.classList.toggle("active", state[key]);
        renderBalanceHistory();
      });
    });

    setView(state.view);
  </script>
</body>
</html>
